<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>LexGUI Docs</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" crossorigin="anonymous" href="https://use.fontawesome.com/releases/v6.7.2/css/all.css">
    <script type="text/javascript" src="docmaker.js"></script>
</head>

<body>

<script type="text/javascript">

    MAKE_HEADER( "Event Handling", "h1", "event-handling" );

    MAKE_PARAGRAPH( `LexGUI relies almost entirely on callbacks when creating each of its widgets and it's not a problem when a callback should be triggered
<strong>only</strong> from one place.` );

    MAKE_HEADER( "Signals", "h2" );
    MAKE_PARAGRAPH( `For those cases where there is no trivial connection between the callbacks and the element that triggers it, LexGUI allows
to create <strong>Signals</strong>. E.g. We could make a widget to be updated when it receives a signal from any location in the application.` );

    MAKE_HEADER( "Connect a Signal", "h3" );
    MAKE_PARAGRAPH( `The following code is creating a widget bound to a signal. That implies that it will be updated when
    it receives the corresponding signal:` );
    MAKE_CODE( `panel.@[mtd]addNumber@(@[str]"Font Size"@, @36@, (value, event) =&gt; {
    console.@[mtd]log@(value);
}, { signal: @[str]"|@on_set_fontsize"@, min: @1@, max: @48@ });` );
    MAKE_PARAGRAPH( `In the case the receiver it's not a widget we could do it using ${INLINE_CODE("LX.addSignal(name, obj, callback)")}:` );
    MAKE_CODE( `LX.@[mtd]addSignal@( @[str]"|@on_value_changed"@, element, value =&gt; {
    console.@[mtd]log@(value);
} );` );
    MAKE_PARAGRAPH( `Note that we are using a callback this time that will called within the element scope when the signal is emitted.`, true );

    MAKE_HEADER( "Emit a Signal", "h3" );
    MAKE_PARAGRAPH( `To emit a signal you will have to call ${INLINE_CODE("LX.emit(signalName, value, options)")} in any of the cases, where ${INLINE_CODE("options")} 
    is optional could have the following attributes:` );

    MAKE_CODE_BULLET_LIST( [
        ["target (DOM element)", "If defined, the callback will be called only to that object."],
        ["skipCallback (Boolean)", "Decide to call the specified widget callback."],
    ] );

    MAKE_LINE_BREAK();
    MAKE_LINE_BREAK();

    </script>

</body>
</html>